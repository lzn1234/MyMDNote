#### HTTP状态码

| 状态码 |               类别               |            含义            |
| :----: | :------------------------------: | :------------------------: |
| `1XX`  |  Informational（信息性状态码）   |     接收的请求正在处理     |
| `2XX`  |      Success（成功状态码）       |      请求正常处理完毕      |
| `3XX`  |   Redirection（重定向状态码）    | 需要进行附加操作以完成请求 |
| `4XX`  | Client Error（客户端错误状态码） |     服务器无法处理请求     |
| `5XX`  | Server Error（服务器错误状态码） |     服务器处理请求出错     |

##### 1xx 信息

- **100 Continue**：表示请求正在处理中，你可以继续发送请求或者忽略该响应。

##### 2xx 成功

- **200 Ok**：正常返回响应报文。
- **204 No Content**：请求处理成功，但是响应实体无主体部分。用于客户端向服务端发送信息，而不需要返回数据时使用。
- **206 Partial Content**：客户端进行了范围请求，响应报文包含制定范围的实体信息。

##### 3xx 重定向

- **301 Moved Permanently** ：永久性重定向
- **302 Found** ：临时性重定向
- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
- **304 Not Modified** ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

##### 4xx 客户端错误

- **400 Bad Request**：请求报文语法错误
- **401 Unauthorized**：该状态码表示发送的请求需要有认证信息。
- **403 Forbidden**：请求被拒绝
- **404 Not Found**：未找到响应页面

##### 5xx 服务器错误

- **500 Internal Server Error**：服务器正在执行请求时发生错误。
- **503 Service Unavaible**：服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求。



#### 连接管理

##### 短连接和长连接

短连接就是每次 HTTP 通信都要进行建立 TCP 连接，长连接是建立一次 TCP 连接就可以进行多次 HTTP 通信。

当浏览器访问一个图片较多的 HTML 页面

- HTTP/1.1 之前，默认建立短连接，如果需要建立长连接需要设置` Connection:Keep-Alive `
- HTTP/1.1 之后，默认建立长连接，如果需要断开连接，需要客户端或者服务端提出断开，即设置 `Connection:Close`

##### 流水线

默认情况下，HTTP 请求按照顺序发出，下一个请求需要在上个请求收到响应之后才会发出，当受到网络延迟限制时，会出现请求阻塞导致的卡顿。

流水线就是在同一条长连接下连续的发送请求而不用等待响应返回，从而降低延迟。

<img src="https://camo.githubusercontent.com/d209aea05562d9c5eea22382e0d13e2d9fa286550034d311a160173967178db3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f48545450315f785f436f6e6e656374696f6e732e706e67" alt="img" style="zoom: 67%;" />



#### Cookie

HTTP 是没有状态的，主要是了让 HTTP 足够简单使得它可以处理大量事务。 HTTP/1.1 引入 Cookie 用于保存状态

#####  Cookie 和 Session 选择

- Cookie 只能存储 ASCII码，而 Session 可以存储各种类型的数据，所以复杂的存储类型要使用 Session
- Cookie 存储在浏览器中，容易被恶意查看，如果需要存储一些比较重要的 Cookie 数据，可以对 Cookie 值进行加密，然后在服务器进行解密。
- Session 存储在服务器中，如果存储所有信息在 Session 中，将产生非常大的开销，所以不建议将所有用户信息存储到 Session 中。



##### 缓存

缓解服务器压力

降低客户端请求资源延迟



#### HTTPS

> HTTPS并非新的协议，而是结合了 SSL 的 HTTP，先让 HTTP 和 SSL 通信，在由 SSL 和 TCP 通信，也就是说 HTTPS 使用了 隧道进行通信。
>
> 使用 SSL，HTTPS 具有 加密（防窃取）、认证（防伪装）、完整性保护（防篡改），弥补了 HTTP 在安全性上的不足。

##### HTTP 的安全性问题

- 使用明文通信，内容可能被<u>窃取</u>
- 无法验证通信方的身份，通信方身份可能会被<u>伪装</u>
- 无法证明报文的完整性，报文可能被<u>篡改</u>。



##### 加密

- 对称密钥加密

  加密和解密使用同一个密钥

- 非对密钥性加密

  客户端使用公开密钥加密，服务端使用私有密钥解密

- HTTPS 采用的加密方式

​		结合非对称加密和对称加密



##### 认证

通过使用**证书**来对通信方进行认证

数据证书认证机构（CA，Certificate Authority）是客服端和服务端都可以信赖的第三方机构。

##### 完整性保护



#### GET 和 POST 的比较

##### 作用

GET 用于请求资源，POST 用于上传资源

##### 参数

GET 和 POST 都能够携带参数，但是 GET 的参数是以字符串的形式拼接在 URL 中，而 POST 的参数存储在实体中。从表面上看，POST 携带参数的方式会比 GET 更安全一些，但仍然可以通过一些抓包工具查看，所以二者的安全性相差不大。

因为 URL 只支持 ASCII 码，所以 GET 参数中的中文需要先进行编码，而 POST 中参数支持标准字符集

##### 安全

安全的 HTTP 方法不会改变服务器状态。

- GET 方法目的是请求服务器资源，不会改变服务器状态，所以它是安全的。

- POST 方法目的是上传实体内容，比如上传用户数据到数据库，所以可能改变服务器的状态，是不安全的。



##### 幂等性

幂等的 HTTP 方法，即一次请求和多次请求的结果是一样的。



##### 可缓存的



##### XMLHttpRequest





#### [HTTP 面试指南](https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md)

