##### 基础部分

- swift 包含 OC 和 C 上的所有基础数据类型：Int Float Double Bool String 和三种集合数据类型 Array Set Dictionary
- 增加了数据类型 Tuple，批量创建或者传递数据
- **增加了可选类型 Optional** ，他是一种数据类型，可以用于表示任何数据 Optional\<Type> ，和 OC 中的 nil 不同的是，nil 表示指针指向的是一片空的地址，所以对于基本数据类型没有 nil 的概念
- swift 是一门**类型安全**的语言，保证所传递的数据类型是你所需要的类型，它会在传递之前检查数据类型，如果不符合就会做出错误警告，同时swift 不允许隐式的类型转换，只能进行显示的类型转换，对一些可能出现转换失败的类型，返回的是可选类型。
- 常量 let，变量 var
- 类型注解，使用类型注解来确定 变量｜常量的数据类型，如果没有设置类型注解的话，swift 会对**初始值**进行**类型推断**来确定这个变它的类型
- `print(_:separator:terminator:)`控制台输出函数
- Int 整数类型，主要分为 Int 和 UInt 两种，使用 .max .min 获取最大值最小值

- 类型一致性，<u>+ 两侧的数据类型要保持一致。</u>
- **类型别名** 使用自定义名字给现有的**类型**起别名，少用为好，影响代码的可读性

- **布尔类型**：控制流位置必须使用布尔类型的判断语句

- **元组类型** ：创建或传递多个数据使用，因为数据之间类型可能是不一致的，所以就有了元组这个类型来管理不同类型的数据。

- 只有可选类型才能使用 nil 赋值，对于**定义了未初始化**的 <u>变量会自动置为 nil</u>， <u>常量需要赋予初始值才能使用</u>

- 可选类型的**强制解析**  `!` ，表示你已经做好了空值处理，该可选类型一定有值。但遇见空值时，强制解析会出现错误，让你直接定位。

- 使用可选绑定来解析可选类型， if let data = optional {} else {}

- **隐式可选类型**：在使用*隐式可选类型*，会根据被赋值的类型来确定是否自动进行解析，一般可以把它当作 *可选类型* 使用，不同的是在 *隐式可选类型 *给 *非可选类型* 赋值的时候会自动进行强制解析

  ```swift
  let assumedString: String! = "An implicitly unwrapped optional string." // 定义一个 隐式可选类型
  
  let implicitString: String = assumedString  // 因为是不可选类型，所以自动强制解析，若为空会报错
  
  let optionalString = assumedString // 根据类型推断，生成的变量是 可选类型（String？）的
  
  ```

- **错误处理**：手动将错误抛出，错误处理等等，主要在错误处理章节中学习

- 断言：当不满足断言中的条件时，会中断程序，利用这个特性来进行代码调试和诊断。



##### 基本运算符（不包含高级运算符）

- 在swift 中的运算符做出了部分改进：赋值符（`=`）不再有返回值，这样避免了你在布尔表达中将  `==  ` 写成 `=` 造成的错误
- 对算术运算符（`+`，`-`，`*`，`/`，`%` 等）的计算结果进行**溢出检测**
- 恒等运算符 `=== `    不恒等运算符 ` !== ` ，用于判断两个对象是够引用同一个对象实例。
- 元组之间的大小比较，类型相同，个数相同的元组才能相互比较，遵循从左到右，依次比较，
- **三元运算符：** ` Bool ? value1 : value2 `，适用于 2 选 1 的场景，但使用较多会影响代码的可读性
- **空合运算符:**` a ?? b`，a必须是一个可选类型，但 a 的值为 nil 时，取 b 值，这个运算符可以用来解析可选类型。
- **区间运算符**，方便的表示一个区间的值
  - `a...b`：**闭区间** 从 a 到 b
  - `a..<b`：**半开区间** 从 a 到 b的前一位
  - `a... ｜ ...a`： **单侧区间** 从 a 到最后



##### 字符串和字符

- 



##### 集合类型

- 



##### [控制流](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/05_control_flow)

- **循环语句**：For-In、While、Repeat-while
- **分支语句**：If、Switch、guard
- **控制转移语句**：continue、break、fallthrough(贯穿)、return、throw

- **Switch**：将一个值和多个模式匹配，和 C语言 switch 语句不同，swift中的 switch 语句匹配模式更加灵活，同时避免隐式的贯穿，更加安全

  - 不需要在末尾添加 break 语句，避免隐式的贯穿
  - 每个 case 匹配语句都必须要有内容
  - 同时匹配多个内容，`case "a","A":`，使用 `,` 分开
  - 匹配模式更加多样：区间匹配、元组匹配
  - 匹配时进行**值绑定**，并在 case 中调用它
  - 使用 where 语句，不会用，后续在学习

- 使用控制转移语句<u>改变代码的执行顺序</u>

  - continue：循环体**结束**当前一次循环，重新进行下一次循环
  - break：
    - 在循环语句中：循环体结束所有循环，直接执行循环体之后的语句
    - 在 switch 语句中：中断 switch 代码块的执行，直接代码块之后的语句

  - Fallthrough：直接执行下一个 case 或 default 语句的内容，不管内容是否匹配。

- **带标签的语句**:在多重嵌套循环的情况下，可以给*循环体或条件语句* 添加**标签**来指定要跳出的循环体或条件语句

  ```
  name :while condition {
  		break name
  		continue name
  }
  ```

- guard语句，用于提前退出

  ```swift
  guard condition else {
  		// 此处必须执行控制转移语句来退出 guard 语句所在的代码段
    	// guard 在函数体内执行时：return、throw
    	// guard 在循环体或条件语句内执行：break、continue
  }
  ```

- 检测API可用：Bool类型的宏：`#available(iOS 8,*)`，用于判断版本，当 iOS 版本 >= 8，执行 if 语句中的代码

  

##### [函数](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/06_functions)

- 使用关键字 `func` 定义一个函数

  ```
  // 名字，参数，返回类型
  func funcName(paramA: type, paramB: type) -> Returntype {
  
  }
  ```

- 使用一个元组来返回**多个返回值**

  ```swift
  func moreReturnfunc() -> (type1, type2) {
    	
  }
  
  func moreReturnfunc() -> (name1: type1, name2: type2) {
    	
  }
  ```

- 当你不确定是否要返回多个值时，你可以用一个**可选元组**来作为返回值

  ```
  func funcName() -> (type1, type2)? {
  
  }
  ```

- **隐式返回的函数**：当函数体内只有一行表达式时，该函数就可以<u>隐式的返回这个表达式</u>，<u>不需要使用 return 来返回值</u>

  ```swift
  func greeting(for person: String) -> String {
      "Hello, " + person + "!"
  }
  print(greeting(for: "Dave"))
  // 打印 "Hello, Dave!"
  
  func anotherGreeting(for person: String) -> String {
      return "Hello, " + person + "!"
  }
  print(anotherGreeting(for: "Dave"))
  // 打印 "Hello, Dave!"
  ```

- **参数名称**：创建函数时定义，**参数标签**：调用函数时使用，<u>默认情况下，函数参数使用参数名称来作为它们的参数标签</u>

  在调用函数时，是通过标签名来传入你的参数的，在创建函数没有指定**参数标签**的话，默认使用**参数名**作为**参数标签**

  ```swift
  // 指定你的参数标签
  func func1(paramLabel paramName: type) {
    
  }
  ```

  你也可以在调用函数时忽略你的参数标签，使用 `_` 来指定标签

  ```swift
  func func1(_ paramName: type) {
  		
  }
  ```

- 给参数添加默认值：创建参数时，给参数指定一个默认值，如果给带有默认值的参数传值，会覆盖默认值

  ```
  func func1(name: String, age: Int = 0) -> Bool {
  	
  }
  ```

- 可变参数：在参数类型后加上 `...` 来声明一个可变参数

  ```
  // 可变参数就是隐式的一个数组
  func func1(_ values: Int...) {
  		for value in values {
  				
  		}
  }
  ```

- 函数中的参数默认都是 **let 常量**类型的，这意味着你不能更改参数值。

- **输入输出参数**：可变的参数类型，和 C 语言的指针类型差不多，使得在函数内对参数的修改工作能存活到函数调用结束

  - 如何定义输出输出参数：使用 `inout` 关键字定义一个传入传出参数

  - 如何调用带有此类参数的函数：传入带有 `&` 的**可变参数**，`&` 表示这个参数可以被修改

  ```swift
  func func1(_ name: inout String, _ age: inout Int) {
    	//
  }
  var name = "lzn"
  var age = 12
  func1(&name,&age)
  ```

- **函数类型**：函数类型由 **参数类型+返回值类型** 组成，`(param1: type1, param: type2) -> returnType`

  你可以使用 `type(of:funcName)` 来查看一个函数的类型

  ```swift
  func func1(_ name: String, _ age: Int) -> Bool {
  
  }
  
  // 初始化一个函数类型
  var func2：(String, Int) -> Bool = func1
  
  ```

  函数类型不能设置函数标签，在调用**函数类型的变量**时相当于调用**忽略了参数标签的函数**

  对于返回值为空的函数来说，你要使用 Void 作为返回值 例如：`(Name: String, age: Int) -> Void`

- **嵌套函数**：在函数内定义局部函数，和局部变量差不多。



##### [闭包](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/07_closures)

- **自包含的函数代码块**
- 闭包可以**捕获**和**存储**其所在<u>上下文中任意常量和变量的引用</u>，在这个过程中，swift 会自动进行内存管理的操作

- 函数本质就是一种特殊的闭包
  - 全局函数是一个**有名字**但**不会捕获任何值**的闭包
  - 嵌套函数是一个**有名字**且会**捕获其封闭函数域内值**的闭包
  - 闭包则是使用轻量级语法所写的**可以捕获其上下文中变量或者常量值**的匿名闭包





##### [枚举](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/08_enumerations)

- 使用 `enum`
- 



##### [类和结构体](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/09_structures_and_classes)

- 和 C 语言中的结构不同，swift 中的结构体功能更加强大，可以定义方法、**扩展(extension)**、**遵循协议(protocol)**、定义构造器用于初始化。你可以把结构体当作一个简化的类

- class 相比于 struct 的附加功能
  - class 可以继承（extend）
  - 类型转换
  - 析构器
  - 引用计数

- 使用 `struct` 关键字引入结构体，`class` 关键字引入类，每一个类和结构体都是一个新的类型，所以要遵循首字母大写的命名规范。 

- 和 OC 一样，你可以使用点语法来访问一个实例的属性，或者进行连续点语法来访问属性的属性。

- 构造器，即初始化方法，每个 struct 都会自动生成成员逐一构造器(init 方法)，class 则需要自己定义

- 结构体和枚举是**值类型**：它们的**实例**在传值时会进行复制，然后将副本传递给变量。这个过程参考**深拷贝**

- 集合类型：`Set、Array、Dictionary` 都是值类型，但如果进行赋值操作时，不会立即发生复制，这时候 *新集合* 和*旧集合* **共享同一份内存空间（浅拷贝） **，**共享集合内的元素**，当某个副本进行值修改时，此时才会进行复制操作（深拷贝）

  ```swift
  var arr1 = [1, 2, 3, 4]
  var arr2 = arr1
  
  printA(address: arr1) // 0x10071e0e0
  printA(address: arr2) // 0x10071e0e0
  
  //arr1[0] = 22
  arr2[0] = 12
  
  printA(address: arr1) // 0x10071e0e0
  printA(address: arr2) // 0x10071e190
  
  // 哪个先 write 哪个先 copy
  ```

  

- 打印内存地址代码

  ```swift
  // 好像这个有误
  //print(Unmanaged.passUnretained(obj as AnyObject).toOpaque())
  
  func printA(address o: UnsafeRawPointer ) {
      print(String(format: "%p", Int(bitPattern: o)))
  }
  ```

- 类是**引用类型**：和值类型不同，引用类型的实力赋值给变量或者常量时，会将引用传递过去，两个变量对应的是同一份内存地址（**浅拷贝**）

- 在<u>调用函数进行传值</u>时，**引用类型**和**值类型**的表现也和赋值时相同，
  - 引用类型传递的是**引用**，相当于输入输出参数，函数内对实例的修改影响会保留到函数外。
  - 值类型传的是copy 后的值。
  
- 恒等运算符 `===` ：判断两个变量或常量是否引用了同一个实例。



##### [属性](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/10_properties#stored-properties)

- swift 中将 属性 分为**存储属性**和**计算属性**，以及**类型属性**
  -  存储属性：将常量或着变量存储为实例的一部分，一般来说，常见的变量均为存储属性
  - 计算属性：从名字上可以看出，计算属性**不直接存储值**，而是通过在类｜结构体中实现 **getter（必选）**和**setter 方法（可选）**来间接获取其他属性或者变量的值。<u>一个计算属性必须明确它的类型</u>
  - 类型属性：和类型本身相关联

  

  - 当创建了一个**结构体常量**，则该实例内的所有属性都<u>无法在修改</u>，即使该属性是 `var` 修饰的
  - 当创建了一个的**类常量**，则可以修改该实例中的可变属性

- **延时加载存储属性**：使用 `lazy` 关键字来声明一个延时加载存储属性，该属性一定要是一个**变量**，因为**延时加载存储属性**只有才第一次调用才会获得其初始值，所以在<u>实例构造完成后</u>**延时加载存储属性**的值可能是空的。<u>而常量属性需要在**实例构造**完成前保证有初始值，所以无法完成**延时加载**的效果</u>

- 延时加载存储属性的多线程问题：当未初始化的延时加载存储属性**同时**被多个线程访问时，无法保证只初始化一次。
- 和 OC 不同，swift 将 实例变量和属性统一，不在区分二者。

- 计算属性的 setter 和 getter 方法的简化
  - 简化 `setter` 声明：当你没有制定参数时，使用默认参数名`newValue`
  - 简化 `getter` 声明：当表达式为单行表达式时，可以不使用 return 直接返回

- **只读计算属性**：直接在属性的括号中填写 getter 方法的内容

  ```swift
  var info: String {
  		return name + String(age)
  }
  ```

- **属性观察器**：监听和相应值的变化，即使新值和旧值相同也会触发。

  使用 `willSet` `didSet` 方法来观察属性值

  - `willSet` 在新值设置之前被调用，用于观察**新值**，默认参数名是 `newValue`
  - `didSet` 在新值设置之后调用，用于记录**旧值**，默认参数名是 `oldValue`

- **属性包装器**：在**属性管理**和**属性定义**代码之间增加一个分隔层。将属性的**处理逻辑**抽离出来使得可以进行批量复用

  被属性包装器修饰的属性，本质就是获取和修改包装器内 `wrappedValue` 的值，你可以设置 `wrappedValue` 为计算属性或者存储属性。

  - 待补充
  - 待补充

- 待学习
- 待学习



##### [方法](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/11_methods)

- 结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一

- 实例方法，通过一个实例调用方法，同属性一样使用点语法调用。
- `self`  属性：即该实例本身，你可以在实例方法中通过 `self` 引用当前实例，同时当属性名和参数名相同时，可以通过 `self.name` 来指定属性
- 如果是枚举、结构体这样的**值类型**，那么普通的实例方法是无法修改其内部的**属性**的，要声明可 `mutating` 方法才行 。
- 在可变方法中给 `self` 赋值，<u>只有值类型才能声明可变方法，且只有值类型才能更改 `self` 实例</u>
- 类型方法，通过类名调用的方法 使用 `static` 声明一个类型方法，其实就是 OC 中的类方法



##### [下标](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/12_subscripts)

- **下标**允许你通过实名后的**方括号**中传入**一个或多个索引值**来对实例进行查询，可以参考**数值**或者**字典**

- 通过 `subscript` 关键字定义下标，其定义语法类似计算属性，下标的读写操作和内部定义的 `set` 和 `get` 操作有关

```swift
subscript(index: Int) -> Int {
    get {
      // 返回一个适当的 Int 类型的值
    }
    set(newValue) {
      // 执行适当的赋值操作
    }
}
```

- 下标是访问集合列表元素的快捷操作。

- 下标接收**任意数量**、**任意类型**的参数，同时可以返回**任意类型**的返回值

- 下标的重载：你可以实现多个下标，使用时下标将通过你传入的参数数量不同和参数来判断不同下标
- 类型下标：使用 `static subscript` 关键字定义一个类型下标，



##### [继承](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/13_inheritance)

- 一个类可以继承另一个类的方法、属性，继承类称为子类，被继承的称为父类（超类），在swift 中，继承特性是区分类和结构体的

- 在定义类时，在类名之后添加 `:superClassName` 来继承一个类

- 使用 `override` 关键字来执行重写操作，表明你需要提供一个自己定制的实现而不是误写了一个重名的方法或者属性。swift 的实例属性、类属性、实例方法、类方法都可以重写
- 使用 `super` 关键字来访问父类的属性和方法
- 在重写一个属性时，要写出他的名字和**类型**，且通过设置 set 和 get 方法来实现属性重写
- 不可以为常量存储属性或者只读计算属性添加属性观察器，因为它们是不可以变的，为它们添加`willSet`

或者 `didSet` 是不恰当的

- **防止重写**：使用`final`关键字修饰属性或者方法来防止它们被重写。
- **防止继承**：使用`final`关键字修饰类来防止它们被继承。



##### [构造过程](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/14_initialization)

- 类和结构体在创建实例时，必须保证存储属性都有一个**初始值**，或是赋予默认值，或是在 `init` 中赋予初始值

- 当你为存储型属性分配默认值或者在构造器中设置初始值时，<u>它们的值是被直接设置的，不会触发任何属性观察者。</u>

- 使用 `init` 关键字创建一个构造器，可以把它当作匿名函数就好了

- 可选属性类型：自动初始化为 `nil`，等价于 `var name:String? = nil`

- 构造过程中常量的赋值：只要在构造过程结束时保证常量有值就行，所以你可以在构造器中赋值常量，而常量一旦赋值就无法改变。

- 结构体的逐一成员构造器：**结构体**会自动生成逐一成员构造器，你可以省略带有默认值的参数来构建函数。

  <u>但当你自定义了一个构造器，结构体就不会生成逐一成员构造器了。</u>

- **构造器代理**：就是构造器复用，结构体和类在构造体代理的实现上有所不同

  - 结构体（值类型）：不支持继承，所以它只能代理给自己的其他构造器。
  - 类：（引用类型）：由于支持继承，所以构造体代理规则更加的复杂，它需要保证其所有继承的存储属性也能够被正确构造。

- 值类型实现构造器代理：使用`init.self`  来调用其他的构造器

  ```swift
  	self.init(origin: Point(x: originX, y: originY), size: size)
  
  ```

- 类的继承和构造过程：为了保证所有存储属性都能有初始值，swift 提供了两种构造器：**指定构造器**和

  **便利构造器**。

- 一个指定构造器将初始化类中提供的**所有属性**，<u>并调用适合的父类构造器让构造过程沿着继承链向上进行</u>

  类倾向于拥有极少的指定构造器，通常一个类应该只有一个**指定构造器**

  每个类都必须至少拥有一个**指定构造器**，在某些情况下，许多类通过继承了**父类**的**指定构造器**而满足了这个条件。

- 指定构造器和便利构造器之间的调用规则

  1. **子类的指定构造器**必须调用**父类**的**指定构造器**
  2. **便利构造器**必须调用**同类**中定义的**其他构造器**
  3. 便利构造器**沿着调用链最后**必须调用到指定构造器

​	指定构造器必须总是**向上代理（调用父类的构造器）** 

​	便利构造器必须总是**横向代理（调用本类里的构造器）** 

> ​	在下图中
>
> 父类定义了 1 个指定构造器和 2 个便利构造器，该类不是子类，所以指定构造器不需要调用父类，两个便利构造器都满足了**规则2（调用其他构造器）**和**规则3（沿着调用链最后调用了类中的指定构造器）**
>
> 子类定义了 2 个指定构造器和 1 个便利构造器，该类作为子类，指定构造器均调用了父类构造器，满足**规则1**，而便利构造器和父类里的一样，满足**规则 2、3**

<img src="/Users/zhennan/Public/Typora Project/swift从入门到起飞/initializerDelegation01_2x.png" alt="img" style="zoom:67%;" />

- 类的两段式构造过程

  - **第一阶段**：每个**存储属性**都赋予一个初始值。
  - **第二阶段**：在新实例准备使用之前进一步自定义它们的**存储属性**

  > 子类指定构造器调用了父类的指定构造器，完成了第一阶段了初始化，进入第二阶段，可以进一步修改父类的属性。

- 两段式的构造过程使得构造过程更加安全，同时在类的层级结构中给予了类更灵活的构造过程

  - 第一阶段保证了**属性在访问前被初始化**

  - 第二阶段使得类能够能灵活的初始化属性



- 未学习



##### [析构过程](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/15_deinitialization)

- *析构器* 只适用于类型，当一个类的实例被释放之前，就会调用析构器。









##### [可选链](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/16_optional_chaining)

##### [错误处理](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/17_error_handling)

##### [并发](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/28_concurrency)

[类型转换](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/18_type_casting)

[嵌套类型](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/19_nested_types)

[扩展](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/20_extensions)



##### 协议

##### 不透明类型

##### 自动引用计数

- swift 使用自动引用计数（ARC）来进行内存管理
- 

vcA -> vcB -> 

##### 内存安全



##### [访问控制](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/26_access_control)

- 通过**访问控制**来限制其他源文件或模块对你代码的访问，让你能够隐藏代码的实现细节，同时提供自定义的接口让别人访问你的代码。这也是面向对象的三大特性之一：**封装**在 swift 语言里的实现基础

- 模块和源文件的概念
- 访问修饰符规定的访问级别
  - open:
  - public
  - internal
  - fileprivate
  - private

- 访问级别基本原则：**实体的访问级别**要**低于**其**定义所在的实体的访问级别**，即**内部实体的访问**要比**包含它的实体访问**更加严格。

- 几种场景建议的访问级别

  - 默认
  - 当 target
  - 框架
  - 单元测试的访问级别

  









##### 高级运算符
